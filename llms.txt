# llms.txt ‚Äî LLM usage preferences for this repository
# Spec: https://llmstxt.org (human-readable policy; parsers should be tolerant)

version: 1
owner: tosin2013
contact: maintainers via GitHub Issues
updated: 2025-10-27

# ============================================================================
# PROJECT CONTEXT: Validated Patterns Toolkit
# ============================================================================

# WHAT IS THIS REPOSITORY?
# This is a REFERENCE IMPLEMENTATION and REUSABLE TOOLKIT for deploying
# Validated Patterns on OpenShift. It provides:
#
# - 7 Production-Ready Ansible Roles (reusable, copy into your projects)
# - Reference Application Examples (Quarkus, OpenShift AI, any workload)
# - Dual-Workflow Architecture (Development + End-User paths)
# - Complete Diataxis Documentation (tutorials, how-tos, references, explanations)
# - Execution Environment (container infrastructure for running Ansible roles)

# HOW PEOPLE USE THIS REPOSITORY:
# ‚úÖ Clone/fork to deploy their own Validated Patterns
# ‚úÖ Copy individual Ansible roles into their own automation projects
# ‚úÖ Use as template for building similar toolkits
# ‚úÖ Reference implementation for various workloads (Quarkus, AI, custom apps)
# ‚úÖ Extend and customize under GPL v3.0 license

# PROJECT GOALS:
# 1. Provide reusable, production-ready Ansible roles for Validated Patterns
# 2. Enable users to easily extract and use roles in their own projects
# 3. Support multiple application types (not just Quarkus)
# 4. Maintain comprehensive documentation (Diataxis framework)
# 5. Demonstrate best practices for pattern deployment on OpenShift

# REPOSITORY MIGRATION (v1.0 Release):
# - OLD: tosin2013/ansible-execution-environment
# - NEW: tosin2013/validated-patterns-ansible-toolkit
# - Reason: Better reflects toolkit nature and reusability focus

# LICENSE: GNU General Public License v3.0
# - Allows copying, modification, and distribution
# - Requires disclosure of source and license inclusion

# General guidance
# - This repository is open source; learning from docs and code is allowed.
# - Do not ingest or retain secrets. Honor the disallow list below.
# - Focus on reusability: roles can be used independently or together.
# - Quarkus app is ONE example; users can deploy notebooks, AI workloads, or any app.

allow:
  - /

disallow:
  # Secrets and local tokens
  - /token
  - /files/optional-configs/

  # Build outputs and temp artifacts
  - /context/
  - /collections/
  - /site/
  - /.venv-docs/
  - /.mkdocs-server.log

  # VCS internals
  - /.git/

# ============================================================================
# PRIORITY DOCUMENTS FOR LLM AGENTS
# ============================================================================

priority:
  # Start here for project understanding
  - /README.md                              # Project overview and quick start
  - /AGENTS.md                              # Agent-specific development rules
  - /docs/RELEASE-PLAN.md                   # v1.0 release plan and goals
  - /docs/RELEASE-QUICK-REFERENCE.md        # Quick reference card

  # Core architecture and decisions
  - /docs/adr/ADR-001-project-vision-and-scope.md  # Project vision
  - /docs/adr/ADR-002-ansible-role-architecture.md # Role architecture
  - /docs/adr/ADR-003-validation-framework.md      # Validation approach
  - /docs/ARCHITECTURE-DIAGRAMS.md          # Visual architecture

  # User guides (dual-workflow)
  - /docs/DEVELOPER-GUIDE.md                # Development workflow (roles 1-2, 4-7)
  - /docs/END-USER-GUIDE.md                 # End-user workflow (role 3)
  - /docs/GUIDES-INDEX.md                   # All guides index

  # Implementation and status
  - /docs/IMPLEMENTATION-PLAN.md            # 16-week implementation plan
  - /docs/PHASE-2.5-COMPLETE.md             # Current phase status

  # Ansible roles (core value)
  - /ansible/roles/                         # 7 production-ready roles
  - /docs/ANSIBLE-ROLES-REFERENCE.md        # Roles reference guide
  - /docs/QUICK-START-ROLES.md              # Quick start for roles

  # Reference applications
  - /quarkus-reference-app/                 # Quarkus example (ONE example)
  - /docs/adr/ADR-004-quarkus-reference-application.md
  - /docs/adr/ADR-009-openshift-ai-validation.md   # OpenShift AI example

  # Build and deployment
  - /execution-environment.yml              # EE configuration
  - /Makefile                               # Build commands
  - /ansible-navigator.yml                  # Ansible Navigator config
  - /values-global.yaml                     # Global configuration
  - /values-hub.yaml                        # Hub configuration

# ============================================================================
# ANSIBLE ROLES (Core Value - Reusable Components)
# ============================================================================

# 8 Production-Ready Ansible Roles (3,460+ LOC):
# 1. validated_patterns_prerequisites - Cluster validation
#    Location: /ansible/roles/validated_patterns_prerequisites/
#    Purpose: Validate OpenShift version, operators, resources
#    Reusable: Yes, copy into any project
#    Tasks: check_openshift_version.yml, check_operators.yml, check_cluster_resources.yml,
#           check_network.yml, check_rbac.yml, check_storage.yml
#
# 2. validated_patterns_common - Helm and GitOps infrastructure
#    Location: /ansible/roles/validated_patterns_common/
#    Purpose: Install Helm, ArgoCD, clustergroup chart
#    Reusable: Yes, foundational infrastructure
#    Tasks: install_collection.yml, configure_helm_repos.yml, deploy_clustergroup_chart.yml
#
# 3. validated_patterns_operator - VP Operator wrapper (simplified)
#    Location: /ansible/roles/validated_patterns_operator/
#    Purpose: Simplified end-user deployment via VP Operator
#    Reusable: Yes, for end-user workflows
#    Tasks: install_operator.yml, create_pattern_cr.yml, wait_for_gitops.yml, validate_deployment.yml
#
# 4. validated_patterns_deploy - Application deployment
#    Location: /ansible/roles/validated_patterns_deploy/
#    Purpose: Deploy applications via ArgoCD, BuildConfigs
#    Reusable: Yes, adapt for any application
#    Tasks: validate_pattern.yml, configure_argocd.yml, deploy_pattern.yml, verify_deployment.yml
#
# 5. validated_patterns_gitea - Git repository management
#    Location: /ansible/roles/validated_patterns_gitea/
#    Purpose: Local development environment with Gitea
#    Reusable: Yes, for local testing
#    Tasks: deploy_operator.yml, create_instance.yml, configure_users.yml, setup_repositories.yml
#
# 6. validated_patterns_secrets - Secrets management
#    Location: /ansible/roles/validated_patterns_secrets/
#    Purpose: Secrets management using External Secrets Operator, Vault, Sealed Secrets
#    Reusable: Yes, security best practices
#    Tasks: validate_secrets.yml, setup_sealed_secrets.yml, manage_credentials.yml
#    CRITICAL: Secrets management is MANDATORY for every pattern deployment
#    Backends: External Secrets Operator (AWS, Vault, Azure, GCP), Sealed Secrets, Kubernetes Secrets
#    Red Hat Docs: https://docs.redhat.com/en/documentation/openshift_container_platform/4.19/html/security_and_compliance/external-secrets-operator-for-red-hat-openshift
#
# 7. validated_patterns_validate - Comprehensive validation
#    Location: /ansible/roles/validated_patterns_validate/
#    Purpose: Pre/post deployment validation, health checks
#    Reusable: Yes, validation framework
#    Tasks: validate_pre_deployment.yml, validate_deployment.yml, validate_post_deployment.yml,
#           validate_health.yml
#
# 8. validated_patterns_cleanup - Resource cleanup
#    Location: /ansible/roles/validated_patterns_cleanup/
#    Purpose: Clean up Pattern CRs, ArgoCD apps, namespaces
#    Reusable: Yes, ESSENTIAL for testing and development
#    Tasks: cleanup_argocd_applications.yml, cleanup_pattern_cr.yml, cleanup_namespaces.yml,
#           cleanup_gitops.yml (optional, rarely used), cleanup_gitea.yml (optional, rarely used),
#           cleanup_operator.yml (optional, rarely used)
#    Note: ALWAYS use this role before E2E tests to ensure clean state
#    Default behavior: Retains GitOps (from common/), Gitea (dev), and Operator (reusable)

# ROLE TASK REUSABILITY:
# Each role uses modular task files (include_tasks) that can be reused independently:
#
# Example: Reuse specific validation tasks in E2E tests
# - include_tasks: ../../ansible/roles/validated_patterns_prerequisites/tasks/check_openshift_version.yml
# - include_tasks: ../../ansible/roles/validated_patterns_validate/tasks/validate_health.yml
#
# AVOID: Re-running entire roles when only specific checks are needed
# - include_role: name: validated_patterns_prerequisites  # Runs ALL checks unnecessarily

# ============================================================================
# REFERENCE APPLICATIONS (Examples - Not the Only Options)
# ============================================================================

# Quarkus Reference App (Included Example):
# - Location: /quarkus-reference-app/
# - Purpose: Example REST API application
# - Note: This is ONE example; users can deploy any containerized application
# - Includes: Helm charts, Tekton pipelines, multi-environment support

# OpenShift AI Validation (Infrastructure Validation):
# - Location: /docs/adr/ADR-009-openshift-ai-validation.md
# - Purpose: Validate RHOAI platform readiness
# - Validates: Notebooks, pipelines, model serving infrastructure
# - Note: Validates platform, not sample applications

# Users Can Deploy:
# - Python Flask/Django applications
# - Node.js applications
# - Spring Boot applications
# - OpenShift AI notebooks and pipelines
# - Machine learning workloads
# - Data processing applications
# - Static websites
# - Any containerized application

# ============================================================================
# DUAL-WORKFLOW ARCHITECTURE
# ============================================================================

# Development Workflow (Granular Control):
# - Uses: Roles 1-2, 4-7
# - Audience: Pattern developers, maintainers, advanced users
# - Guide: /docs/DEVELOPER-GUIDE.md
# - Purpose: Full control over deployment process

# End-User Workflow (Simplified):
# - Uses: Role 3 (VP Operator)
# - Audience: Pattern consumers, production deployments
# - Guide: /docs/END-USER-GUIDE.md
# - Purpose: Simplified deployment via Validated Patterns Operator

# ============================================================================
# SECRETS MANAGEMENT (CRITICAL - MANDATORY FOR EVERY DEPLOYMENT)
# ============================================================================

# IMPORTANT: Secrets management is NOT OPTIONAL - every pattern MUST implement it properly.
#
# REQUIRED READING:
# üìñ Red Hat OpenShift External Secrets Operator Documentation:
#    https://docs.redhat.com/en/documentation/openshift_container_platform/4.19/html/security_and_compliance/external-secrets-operator-for-red-hat-openshift
#
# TOOLKIT IMPLEMENTATION:
# The validated_patterns_secrets role provides comprehensive secrets management:
# - Location: /ansible/roles/validated_patterns_secrets/
# - Includes: External Secrets Operator setup, SecretStore creation, RBAC, audit logging
# - Must be included: In every pattern deployment playbook
# - Documentation: See /docs/ and AGENTS.md "Secrets Management Guidelines"
#
# RECOMMENDED BACKENDS (Production Priority):
# 1. External Secrets Operator + AWS Secrets Manager (Cloud-native, AWS environments)
# 2. External Secrets Operator + HashiCorp Vault (Enterprise, multi-backend)
# 3. External Secrets Operator + Azure Key Vault (Azure environments)
# 4. External Secrets Operator + GCP Secret Manager (GCP environments)
# 5. Sealed Secrets (GitOps-friendly, development, non-critical data)
#
# NOT RECOMMENDED (Development Only):
# ‚ùå Kubernetes Secrets - base64 is NOT encryption
# ‚ùå ConfigMaps - no encryption support
# ‚ùå Hardcoded credentials - security risk
#
# ONBOARDING.md SECTION:
# - See ONBOARDING.md "Part 4: Secrets Management (CRITICAL - Must Have)"
# - Includes: Implementation checklist, reference documentation, backend selection
#
# AGENTS.md SECTION:
# - See AGENTS.md "Secrets Management Guidelines (CRITICAL - MUST IMPLEMENT)"
# - Includes: Step-by-step implementation, YAML examples, common mistakes to avoid
#
# DEPLOYMENT CHECKLIST (Before deploying ANY pattern):
# ‚úÖ Secrets backend selected (AWS, Vault, Azure, GCP, or Sealed Secrets)
# ‚úÖ Backend credentials configured in cluster or via OIDC
# ‚úÖ validated_patterns_secrets role included in deployment playbook
# ‚úÖ SecretStore/ClusterSecretStore created in pattern namespace
# ‚úÖ External Secrets defined for each credential type
# ‚úÖ Secret rotation policies configured (if backend supports it)
# ‚úÖ RBAC policies set (who can read/write secrets)
# ‚úÖ Audit logging enabled (for compliance requirements)
# ‚úÖ Tested with dummy values (non-sensitive credentials first)
#
# WHAT REQUIRES SECRETS MANAGEMENT:
# - Database credentials (PostgreSQL, MongoDB, MySQL)
# - API keys and tokens (OAuth, JWT, external APIs)
# - TLS certificates and private keys
# - SSH keys and passphrases
# - OAuth client secrets
# - Third-party service credentials (cloud providers, SaaS platforms)
# - Application configuration secrets
#
# COMPLIANCE & AUDIT:
# - Use External Secrets Operator for audit-trail capability
# - Implement RBAC policies for secret access
# - Enable audit logging in your secrets backend
# - Required for: PCI-DSS, HIPAA, SOC2, GDPR compliance

# ============================================================================

# Tutorials (Learning-oriented):
# - /docs/tutorials/

# How-To Guides (Task-oriented):
# - /docs/how-to/

# Reference (Information-oriented):
# - /docs/reference/

# Explanation (Understanding-oriented):
# - /docs/explanation/

# Architectural Decision Records (ADRs):
# - /docs/adr/ (13 ADRs documenting key decisions)

# ============================================================================
# NOTES TO LLM TOOLS/AGENTS
# ============================================================================

# IMPORTANT CONTEXT:
# 1. This is a REFERENCE IMPLEMENTATION - users will clone/fork/copy code
# 2. Ansible roles are REUSABLE - can be used independently or together
# 3. Quarkus app is ONE EXAMPLE - not the only application type
# 4. EE building is INFRASTRUCTURE - not the primary focus
# 5. GPL v3.0 LICENSE - allows copying and modification

# CRITICAL CLARIFICATIONS (Common Confusion Points):
#
# 1. PATTERN NAME: "validated-patterns-ansible-toolkit" is the REFERENCE PATTERN NAME
#    - Users should change this to their own pattern name in:
#      - values-global.yaml (global.pattern)
#      - values-hub.yaml (pattern-specific config)
#      - cleanup role variables (cleanup_pattern_name)
#    - This is a TEMPLATE - not meant to be used as-is in production
#
# 2. VALUES FILES: values-global.yaml and values-hub.yaml are EXAMPLES
#    - Users should customize these with their own:
#      - Git repository URLs (point to their fork or custom repo)
#      - Pattern names
#      - Namespace names
#      - Application configurations
#    - These files are NOT used by EE build - only by pattern deployment
#
# 3. DEPLOYMENT PLAYBOOKS:
#    - ansible/playbooks/deploy_complete_pattern.yml - Development workflow (uses roles 1-2, 4-7)
#    - Use validated_patterns_operator role directly - End-user workflow (simplified)
#    - Choose based on need for granular control vs. simplicity
#
# 4. COMMON SUBTREE (common/):
#    - Used DURING PATTERN DEPLOYMENT (not EE build)
#    - Contains pattern installation chart and scripts
#    - common/Makefile provides operator-deploy, validate-prereq, etc.
#    - Keep synchronized with upstream validatedpatterns/common.git
#
# 5. DUAL WORKFLOWS:
#    - Development Workflow: Step-by-step using individual roles (prerequisites -> common -> deploy -> validate)
#      Use when: Building new patterns, debugging, learning, customizing
#    - End-User Workflow: Single operator role (validated_patterns_operator)
#      Use when: Deploying existing patterns, production, simplicity needed

# WHEN WORKING WITH THIS REPOSITORY:
# - Focus on reusability: make roles easy to extract and use
# - Document multiple application examples (not just Quarkus)
# - Preserve dual-workflow architecture (development + end-user)
# - Follow Diataxis documentation framework
# - Respect ADR decisions (see /docs/adr/)
# - Use AGENTS.md for development rules and conventions

# COMMON TASKS:
# - Adding new roles: Follow ADR-002 architecture
# - Adding new applications: Follow Quarkus example structure
# - Updating documentation: Use Diataxis categories
# - Making architectural decisions: Create new ADR
# - Testing changes: Use Makefile targets (build, test, validate)

# SECURITY:
# - Do not request or store RHSM activation keys or Hub tokens
# - Use pre-commit hooks with gitleaks (v1.0 release)
# - Follow security best practices in validated_patterns_secrets role
# - Validate RBAC and network policies

# BUILD AND TEST:
# - make clean      # Remove build artifacts
# - make token      # Verify ANSIBLE_HUB_TOKEN
# - make build      # Build EE image
# - make test       # Run playbook with ansible-navigator
# - make lint       # Run yamllint
# - make publish    # Push image to registry

# DEPLOYMENT:
# - Development: ansible-playbook ansible/playbooks/deploy_complete_pattern.yml
# - End-User: Use VP Operator (see END-USER-GUIDE.md)
# - Testing: See /tests/ directory for integration tests

# ============================================================================
# END-TO-END TESTING & CLEANUP (CRITICAL FOR DEVELOPMENT)
# ============================================================================

# CLEANUP BEFORE TESTING (MANDATORY):
# Always clean up before running e2e tests to ensure fresh state and avoid conflicts.
#
# Option 1: Use validated_patterns_cleanup role (RECOMMENDED for E2E tests)
# - include_role:
#     name: validated_patterns_cleanup
#   # Default behavior retains shared infrastructure:
#   # cleanup_gitops: false   # Keep ArgoCD (from common/ subtree)
#   # cleanup_gitea: false    # Keep Gitea (for development)
#   # cleanup_operator: false # Keep operator (reusable)
#
# Option 2: Automated cleanup script
# ./tests/integration/cleanup/cleanup.sh
#
# Option 3: Ansible cleanup playbook
# ansible-playbook tests/integration/cleanup/cleanup_deployment.yml
#
# Option 4: Manual cleanup using oc commands
# oc delete pattern <pattern-name> -n openshift-operators
# oc delete applications --all -n openshift-gitops
# oc delete namespace validated-patterns quarkus-app-dev quarkus-app-prod
#
# RESOURCES TO CLEAN (checklist):
# ‚úÖ Pattern Custom Resources (oc get pattern -A) ‚Äî ALWAYS
# ‚úÖ ArgoCD Applications (oc get applications -n openshift-gitops) ‚Äî ALWAYS
# ‚úÖ Application namespaces (validated-patterns, quarkus-app-*, etc.) ‚Äî ALWAYS
# ‚úÖ ConfigMaps and Secrets created by patterns ‚Äî ALWAYS
# ‚úÖ BuildConfigs and ImageStreams (if testing builds) ‚Äî ALWAYS
# ‚úÖ Routes and Services (application-specific) ‚Äî ALWAYS
# ‚ö†Ô∏è  OpenShift GitOps namespace ‚Äî RARELY (only if common/ subtree requires redeployment)
# ‚ö†Ô∏è  Gitea namespace ‚Äî RARELY (only if starting completely fresh)
# ‚ö†Ô∏è  Subscriptions and CSVs ‚Äî RARELY (only if testing operator installation itself)

# E2E TESTING BEST PRACTICES:
# 1. Clean up before testing: Use validated_patterns_cleanup role (MANDATORY)
# 2. Use Ansible roles for deployment: Use validated_patterns_operator or validated_patterns_deploy
# 3. Reuse role tasks, not entire roles: Include specific task files for validation
# 4. Test in isolation: Each e2e test should be independently runnable
# 5. Validate cleanup: Ensure all resources removed after completion
# 6. Document test scenarios: Clearly explain what each test validates
#
# Example: E2E test structure using roles
# - name: Pre-test cleanup
#   include_role:
#     name: validated_patterns_cleanup
#
# - name: Deploy pattern
#   include_role:
#     name: validated_patterns_operator
#
# - name: Validate deployment (reuse specific tasks)
#   include_tasks: ../../ansible/roles/validated_patterns_validate/tasks/validate_health.yml
#
# - name: Post-test cleanup
#   include_role:
#     name: validated_patterns_cleanup
#
# AVOID: Re-running entire roles unnecessarily during validation
# - include_role: name: validated_patterns_prerequisites  # Runs ALL checks

# VERIFY CLEANUP COMPLETENESS:
# oc get pattern -A
# oc get applications -n openshift-gitops
# oc get namespaces | grep -E 'validated-patterns|quarkus-app'
# oc get csv -n openshift-operators | grep patterns-operator

# ============================================================================
# COMMON SUBTREE MANAGEMENT (CRITICAL)
# ============================================================================

# The common/ directory is a git subtree from:
# https://github.com/validatedpatterns/common.git
#
# ‚ö†Ô∏è  IMPORTANT: This repository updates FREQUENTLY. Keep in sync!
#
# ARCHITECTURE NOTE:
# - common/ is NEVER used standalone - it's imported as a subtree into each pattern
# - GitOps/ArgoCD is deployed BY THE COMMON SUBTREE
# - This is why cleanup typically RETAINS GitOps (it's shared infrastructure)
# - Only delete GitOps when common/ subtree changes require redeployment
#
# UPDATE PROCEDURE (before major development):
# Option 1: Using utilities script (recommended)
# curl -s https://raw.githubusercontent.com/validatedpatterns/utilities/main/scripts/update-common-everywhere.sh | bash
#
# Option 2: Manual update
# git remote add -f common-upstream https://github.com/validatedpatterns/common.git
# git merge -s subtree -Xtheirs -Xsubtree=common common-upstream/main
#
# CHECK VERSION:
# cd common/ && git log --oneline -n 5 && cd ..
#
# WHEN TO UPDATE:
# ‚úÖ Before starting new feature development
# ‚úÖ Before running comprehensive e2e tests
# ‚úÖ When pattern deployment fails with unknown errors
# ‚úÖ When upstream releases new features/fixes
# ‚úÖ Monthly or before major releases
#
# VERIFY INTEGRATION:
# make -f common/Makefile help

# ============================================================================
# MAKEFILE INTEGRATION
# ============================================================================

# TWO MAKEFILES WORK TOGETHER:
# 1. Root Makefile: EE building, testing, docs, pattern deployment via ansible-navigator
# 2. Common Makefile (common/Makefile): Pattern installation, validation, secrets, ArgoCD health
#
# ROOT MAKEFILE COMMANDS:
# make build test                    # Build and test EE
# make deploy-pattern PATTERN_NAME=<name>
# make validate-pattern PATTERN_NAME=<name>
#
# COMMON MAKEFILE COMMANDS:
# make -f common/Makefile operator-deploy        # Deploy via VP Operator
# make -f common/Makefile validate-prereq        # Verify prerequisites
# make -f common/Makefile validate-origin        # Verify git access
# make -f common/Makefile load-secrets           # Load secrets
# make -f common/Makefile argo-healthcheck       # Check ArgoCD apps
# make -f common/Makefile uninstall              # Uninstall pattern
#
# EXAMPLE WORKFLOW (using Ansible roles):
# 1. Update common: curl -s https://raw.githubusercontent.com/validatedpatterns/utilities/main/scripts/update-common-everywhere.sh | bash
# 2. Clean cluster: ansible-playbook -e cleanup_confirm=false ansible/playbooks/cleanup_pattern.yml (or use role directly)
# 3. Build EE: make build test
# 4. Deploy pattern: ansible-playbook ansible/playbooks/deploy_complete_pattern.yml (or use validated_patterns_operator role)
# 5. Validate: use validated_patterns_validate role or specific task files
# 6. Run e2e tests: ansible-navigator run tests/integration/playbooks/test_end_to_end.yml
# 7. Post-test cleanup: use validated_patterns_cleanup role
#
# ALTERNATIVE WORKFLOW (using Makefiles):
# 1. Update common: curl -s https://raw.githubusercontent.com/validatedpatterns/utilities/main/scripts/update-common-everywhere.sh | bash
# 2. Clean cluster: ./tests/integration/cleanup/cleanup.sh
# 3. Build EE: make build test
# 4. Deploy pattern: make -f common/Makefile operator-deploy
# 5. Validate: make -f common/Makefile validate-prereq argo-healthcheck
# 6. Run e2e tests: ansible-navigator run tests/integration/playbooks/test_end_to_end.yml
